-   [How Multiplexing Changes Your HTTP APIs](https://www.mnot.net/blog/2019/10/13/h2_api_multiplexing)
    -   قبلا اگه می‌خواستیم 40 ریکوئست به سرور بزنیم، 40 کانکشن ایجاد میشد
    -   اما با استفاده از HTTP/2 می‌تونیم RESTFUL بنویسیم
    -   چون درخواست‌های متعدد یکجا ارسال میشن به سرور و دیگه نیازی به ابزارهایی مثل GraphQL نیست
    -   البته سرور هم باید کانفیگ بشه که بتونه این درخواست‌ها رو هندل کنه

-   [Caching Tutorial](https://www.mnot.net/cache_docs/)
    -   توضیحاتی درمورد نحوه‌ی کش کردن بروزر و پروکسی‌ها
    -   Validator
        -   هدرهای ETag و Last-Modified می‌تونه نقش ولیدیتور رو بازی کنه
        -   تایید می‌کنن که کش فعلی، معتبره یا فاسد شده
    -   Freshener
    -   هدرهای Expires و Cache-Control
        -   میگن ریسپانس به چه شکلی و تا چه زمانی کش بشه
        -   مثلا به پروکسی‌ها میگن کش نکن، ولی بروزر کش کنه
        -   زمان کش ابسولوت نیست و نسبت به زمان ریکوئست، در نظر گرفته میشه
    -   [https://redbot.org/](https://redbot.org/)

-   [Can GraphQL Replace REST? A Study of Their Efficiency and Viability](https://ieeexplore.ieee.org/document/9474834/)
    -   نتیجه‌ی مقایسه‌ی REST و GraphQL خیلی بهم نزدیک بوده
    -   بیان شد که یادگیری گراف‌کیو‌ال، خیلی دشوار و زمان‌بره و ابزارهای مناسبی براش نیست
        -   بخاطر اینکه رست بیشتر جا افتاده و بالغتر شده این مسئله وجود داره که با جا افتادن گراف هم ابزارهای مناسبی براش ساخته میشه
    -   در کل پیاده کردن گراف سختتره و برای پروژه‌های کوچیک و متوسط زیاد ارزش نداره
        -   البته اینم بستگی به پروژه داره و اینکه قراره اطلاعات رو به چه شکلی دریافت کنه
            -   اگه دریافت اطلاعات با گراف و رست، از نظر زمانی و منابع و ... تفاوتی نداره، رست در ارجحیته

-   [Production ready GraphQL](https://book.productionreadygraphql.com/)
    -   قبلا از APIهای One-size-fits-all استفاده می‌شد
        -   مشکل این بود که این ای‌پی‌آی‌ها باید خیلی جنریک نوشته می‌شدند و اطلاعات زیاد و بیهوده‌ای رو به تمامی دستگاه‌ها ارسال می‌کردند
        -   این روش، معمولا به شکل‌های زیر استفاده می‌شد:
        -   مثلا وقتی می‌خواستیم محصولات رو هم در موبایل نشون بدیم، هم در وب، می‌تونستیم این کار رو بکنیم:
            -   /api/mobile/products
            -   /api/web/products
        -   یا به شکل زیر:
            -   /api/products?version=minimal
            -   /api/products?version=full
        -   یا اینکه بذاریم کلاینت، فیلد‌ها رو انتخاب کنه
        -   JSON:API اسمش رو گذاشته sparse fieldsets
            -   /api/products?include=author&fields[products]=name,price
        -   گوگل درایو از این استفاده کرده و یه چیزی شبیه زبان سمت کلاینت خودش رو ساخته
            -   /api/products?fields=name,photos(title,metadata,size)
    -   OSFA, کار رو برای سازنده راحت می‌کنه، نه برای کلاینت یا استفاده کننده
    - چون نگهداری از روش‌هایی که گفته شد دشواره، همه دنبال راه جایگزینی بودند
        - شرکتی مثل نت‌فلیکس که بیشتر از 800 دستگاه مختلف رو پشتیبانی می‌کرد، یه لایه بین کلاین و سرور ایجاد کرد که سرور اطلاعات رو جمع کنه و این لایه، مطابق با خواسته‌ی کاربر، اطلاعات رو ارسال کنه
        - ساندکلاد هم همین کار رو کرد. چون از میکروسرویس‌ها استفاده می‌کرد، باید ریکوئست‌های زیادی می‌زد که برای کلاینت بهینه نبود
            - در اصل برای هر سیستم/دستگاه، یک ای‌پی‌آی مجزا ساختند
            - اینجوری دیگه لازم نبود هنگام تغییر در ای‌پی‌آی، نگران سایر دستگاه‌ها باشن و می‌تونستن برای هر دستگاه، یه ای‌پی‌آی بهینه بسازن
            - اسم این لایه رو گذاشتن Backends for Frontends
        - فیسبوک هم با همین مشکلات مواجه شد و در سال 2015، GraphQL رو معرفی کرد
            - GraphQL یک روش (specification) برای نوشتن کوئری (API Query Language) و یک انجین در سمت سرور برای اجرای اون کوئریه
    - ترجمه کردن کوئری‌ها توسط Type System انجام میشه
        - Schemaها رو با SDL (Schema Definition Language) می‌نویسیم
    - Roots
        - Query
        - Mutation
        - Type
        - Input
        - Enum
        - Interface
            مثل سایر زبان‌ها استفاده میشه
        - Fragments
            - می‌تونیم تکه‌ای از پراپرتی‌ها رو جدا کنیم و داخل یک فرگمنت بذاریم تا در جاهای مختلف ازش استفاده کنیم
            ```
            fragment ProductFragment on Product {
                name
                price
                variants
            }
            ```
        - Union
            ```
            union CartItem = Product | GiftCard
            type Cart {
                items: [CartItem]
            }
            ```
        - Scalar
            - اسکالرها، مثل برگ‌های کوئری می‌مونن که دیگه هیچ زیرمجموعه‌ای ندارن
                - Int
                - String
                - Float
                - Boolean
                - ID: یه شناسه‌ی یونیک که به عنوان کلید کش استفاده میشه. در اصل استرینگه، اما با انتخاب به عنوان ID مشخص می‌کنیم که این فیلد human-readable نیست
                - سایر موارد رو هم میشه بصورت دستی تعریف کرد (در ادامه از مثال‌هاش استفاده شده)
    - قبل از پیاده‌سازی، باید طراحی رو انجام بدیم
    - طراحی باید از دید کاربر انجام بشه، نه منابع سیستم و بک‌اند
    - Action verbs:
        - در REST:
            - از متدهای HTTP استفاده می‌کنیم
                - PUT /user/
                - POST /product/
        - در GraphQL:
            - بهتره از رویه‌ها (Procedure) استفاده کنیم:
                - updateUser
                - createProduct
        - استفاده از Principle of least astonishment
            - نام‌گذاری و ساخت ورب‌هایی که کاربر رو غافلگیر نکنه
            - برای مثال، وقتی publishPost داریم، یوزر انتظار داره که unpublishPost هم داشته باشیم
            - یا مثلا اگه در همه‌ی سایت‌ها فشردن دکمه‌ی `/`، نوار جستجو رو نشون میده، یه شرتکات خلاف قاعده براش نذاریم و از همون متد استفاده کنیم تا کاربر غافلگیر نشه
    - باید تا جایی که می‌تونیم از تایپ‌های GraphQL استفاده کنیم
        - برای مثال، بجای اینکه به شکل زیر عمل کنیم
        ```
        type Product {
            metaAttributes: JSON!
        }
        ```
        می‌تونیم از مدل زیر استفاده کنیم:
        ```
        type ProductMetaAttribute {
            key: String!
            value: String!
        }
        type Product {
            metaAttributes: [ProductMetaAttribute!]!
        }
        ```
        به این شکل، اگه خواستیم اسکیما رو گسترش بدیم، لازم نیست نگران این باشیم که کدهای قبلی بهم بریزه
        - یا اینکه از مقادیر اسکالر استفاده کنیم:
        ```
        type Product {
            description: Markdown
        }
        scalar Markdown
        ```
        - در کل، درصورتی که می‌تونیم از اسکیمای قوی‌تری استفاده کنیم، نباید از تایپ‌های String و ... استفاده بشه و باید حتی‌الامکان شکسته بشه به مقادیر کوچکتر یا دقیق‌تر
    - برای جلوگیری از misuse شدن:
        - می‌تونیم از پارامترهای اختیاری جلوگیری کنیم:
            - بجای اینکه یه `findProduct(id: ID, name: String)` بنویسیم و بعدا بخوایم هندل کنیم که اگه کاربر هم آیدی داد و هم اسم داد، یا هیچکدوم رو نداد باید چیکار کنیم، می‌تونیم بهتر بنویسیم:
            ```
            type Query {
                productByID(id: ID!): Product
                productByName(name: String!): Product
            }
            ```
            چون قراره کاربر از این ای‌پی‌آی استفاده کنه و براش مفهوم باشه، اصلا مهم نیست که چه تعداد روش برای دریافت اطلاعات تعریف کنیم. فقط باید واضح باشه و اطلاعات مفیدی ارائه کنه
    - وقتی نتایج زیاد میشه، باید از Pagination استفاده کنیم. دو نوع استایل داریم:
        - Offset pagination:
            - استایلی که در دیتابیس‌ها هم استفاده می‌کنیم
            - مشکلش اینه که وقتی تعداد آیتم‌ها زیاد شد و از Offsetهای بزرگ استفاده کردیم، دیتابیس تمامی رکوردها تا اون آفست رو لود می‌کنه و بعد از Offset تا Limit رو برمی‌گردونه که کار سنگینیه
            - دوم اینکه اگه در حال اضافه کردن ردیف به دیتابیس باشیم، ممکنه تعدادی از نتایج صفحه‌ی اول در صفحه‌ی دوم هم نمایش داده بشن. یعنی دیتا ثبات نداشته باشه.
        - Cursor pagination:
            - یه کرسر داریم که باهاش سایر داده‌ها رو بگیریم (کرسر می‌تونه آیدی ردیف باشه)
            - `SELECT * FROM products WHERE id > 15 ORDER BY id DESC LIMIT 10`
            - مشکل این روش اینه که کاربر نمی‌تونه بپره هر صفحه‌ای که خواست
            - اما مشکل پرفورمنس بک‌اند نداریم
    - بهتره از یک Type در مکان‌های مختلف استفاده نکنیم
        - اگه استفاده کنیم، مجبور میشیم یه سری فیلد اضافه کنیم
        - یا یه سری از فیلد‌ها رو اختیاری کنیم و نذاریم اسکیما Validation رو انجام بده
            - مثلا اگه از یه تایپ برای ساختن و آپدیت کردن محصول استفاده کنیم:
                - برای ساختن، نام محصول اجباریه
                - برای آپدیت کردن، نام محصول اجباری نیست
                - بنابراین این فیلد باید اختیاری بشه و ولیدیشن در کد انجام بگیره که کار خوبی نیست
    - می‌تونیم Nodeها رو بصورت مستقیم از طریق Global Identification پیدا کنیم
        - هر آیتم یک آیدی داره که با اون پیدا میشه
        - میشه در این آیدی، اطلاعات مفیدی مثل شماره‌ی دیتابیس (برای کلاسترها) یا مثلا شماره‌ی فروشگاه در مارکت‌پلیس رو قرار داد
